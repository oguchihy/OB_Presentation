---
title: "Time to Event Analysis with Interactive Shiny App"
author: "Your Name"
date: "2024-05-13"
format: 
  html:
    embed-resources: true
server: 
  type: shiny
---

## Introduction

This document provides an analysis of obstetric delivery data using both static and interactive elements. The interactive segment allows users to explore the data and model outputs dynamically.

## Static Analysis

Here, we provide a static analysis of the data.

```{r static-analysis, echo=FALSE, message=FALSE, warning=FALSE}
# Load necessary libraries
library(dplyr)
library(ggplot2)

# Load data
ob_data <- readRDS("Factorized OB DATA with Selected Variables.RDS")

# Calculate data ranges and other metrics
dte_range_NMC_data <- range(ob_data$adm_date)
del_tm_dur_range <- round(range((ob_data$gest_age_days) / 7), 1)
age_range <- range(ob_data$age)
nbr_del_nmc <- nrow(ob_data)
prcnt_preterm <- round(sum(ob_data$gest_age_days < 259) / sum(ob_data$gest_age_days >= 140) * 100, 0)
gest_age_range <- range(ob_data$gest_age_days, na.rm = TRUE)
prcnt_hghRsk <- round(sum(ob_data$hghRsk == "yes") / nrow(ob_data) * 100, 0)


# Load data
ob_data <- readRDS("Factorized OB DATA with Selected Variables.RDS")

# Convert adm_to_del_tm_cat to a factor
ob_data <- ob_data %>%
  mutate(adm_to_del_tm_cat = factor(case_when(
    adm_to_del_tm < 12 ~ "Under 12 hours",
    adm_to_del_tm >= 12 & adm_to_del_tm < 24 ~ "13-24 hours",
    adm_to_del_tm >= 24 & adm_to_del_tm < 48 ~ "25-48 hours",
    adm_to_del_tm >= 48 ~ "Over 48 hours"
  )))
# Load necessary libraries
library(randomForest)
library(dplyr)
library(ggplot2)



# # Function to calculate variable importance for a given outcome
# calculate_varimp <- function(outcome, data) {
#     formula <- as.formula(paste(outcome, "~ ."))
#     model <- randomForest(formula, data = data, importance = TRUE)
#     importance <- importance(model)
#     importance_df <- data.frame(
#         Predictor = rownames(importance),
#         Importance = importance[, 1],
#         Rank = rank(-importance[, 1])
#     )
#     return(importance_df)
# }
# 
# # Define outcomes
# outcomes <- c("adm_to_del_tm_cat", "conditions_cnsldt", "cluster", "delivery_cnsldt")
# 
# # Calculate variable importance for each outcome
# varimp_list <- lapply(outcomes, calculate_varimp, data = ob_data)
# 
# # Determine significant predictors for each outcome (using a threshold, e.g., top 10% importance)
# thresholds <- sapply(varimp_list, function(df) quantile(df$Importance, 0.9))
# significant_predictors <- mapply(function(df, threshold) {
#     df %>%
#         filter(Importance >= threshold) %>%
#         select(Predictor, Rank)
# }, varimp_list, thresholds, SIMPLIFY = FALSE)
# 
# # Count the number of outcomes each predictor affects significantly
# predictor_counts <- table(unlist(lapply(significant_predictors, `[[`, "Predictor")))
# 
# # Filter predictors that affect all outcomes
# top_predictors <- names(predictor_counts[predictor_counts == length(outcomes)])
# 
# # Aggregate ranks for these top predictors across outcomes
# aggregate_ranks <- sapply(top_predictors, function(predictor) {
#     sum(unlist(lapply(significant_predictors, function(df) {
#         if (predictor %in% df$Predictor) {
#             return(df$Rank[df$Predictor == predictor])
#         } else {
#             return(Inf)  # If predictor is not in the top for an outcome, assign a high rank
#         }
#     })))
# })
# 
# # Create a data frame with the results
# meta_varimp <- data.frame(
#     Predictor = top_predictors,
#     AggregateRank = aggregate_ranks
# ) %>%
#     arrange(AggregateRank)
# 
# # Plot the meta-variable importance
# ggplot(meta_varimp, aes(x = reorder(Predictor, -AggregateRank), y = AggregateRank, fill = AggregateRank)) +
#     geom_bar(stat = "identity") +
#     coord_flip() +
#     labs(title = "Meta-Variable Importance by Aggregate Rank", x = "Predictors", y = "Aggregate Rank") +
#     theme_minimal() +
#     scale_fill_gradient(low = "blue", high = "red")
# 

```

library(shiny)
library(survival)
library(survminer)
library(ggplot2)
library(myRFunctions)  # Assuming this contains ggforest3
library(nnet)  # for multinom()
library(dplyr)
library(randomForest)

# Load data
ob_data <- readRDS("Factorized OB DATA with Selected Variables.RDS")

# Define UI
ui <- fluidPage(
    titlePanel("Time to Event Analysis"),
    sidebarLayout(
        sidebarPanel(
            selectInput("predictor", "Choose Predictor for Cox Model:", choices = colnames(ob_data)),
            selectInput("strataVar", "Choose Stratification Variable:", choices = c("None", colnames(ob_data))),
            selectInput("multinomOutcome", "Choose Outcome for Multinomial Logistic Regression:", 
                        choices = c("adm_to_del_tm_cat", "intrapartal_events", "conditions_cnsldt")),
            selectInput("multinomPredictor", "Choose Predictor for Multinomial Logistic Regression:", 
                        choices = colnames(ob_data)),
            selectInput("varImpOutcome", "Choose Outcome for Variable Importance:", 
                        choices = c("adm_to_del_tm_cat", "conditions_cnsldt", "cluster", "delivery_cnsldt")),
            actionButton("updateModel", "Update Model")
        ),
        mainPanel(
            tabsetPanel(
                tabPanel("Survival Plot", plotOutput("survPlot")),
                tabPanel("Cumulative Hazard Plot", plotOutput("cumHazPlot")),
                tabPanel("Kaplan-Meier Plot", plotOutput("kmPlot")),
                tabPanel("Hazard Ratios", plotOutput("hrPlot")),
                tabPanel("Multinomial Coefficients", plotOutput("multiCoeffs")),
                tabPanel("Variable Importance", plotOutput("varImportancePlot"))  # New tab for variable importance
            )
        )
    )
)

# Define Server
server <- function(input, output, session) {
    set.seed(123)  # For reproducibility

    fitModel <- eventReactive(input$updateModel, {
        strata_part <- if(input$strataVar != "None") paste("+ strata(", input$strataVar, ")", sep="") else ""
        formula <- as.formula(paste("Surv(adm_to_del_tm, event) ~", input$predictor, strata_part))
        model <- coxph(formula, data = ob_data)
        print(summary(model))  # Debugging model output
        return(model)
    })
    
    fitMultinom <- eventReactive(input$updateModel, {
        # Use a smaller subset for multinomial logistic regression to simplify computation
        ob_data_subset <- ob_data %>% sample_n(500)  # Adjust the number as needed
        
        formula <- as.formula(paste(input$multinomOutcome, "~", input$multinomPredictor))
        multinom_model <- multinom(formula, data = ob_data_subset, maxit = 100)
        print(summary(multinom_model))  # Debugging model output
        return(multinom_model)
    })
    
    output$survPlot <- renderPlot({
        fit <- fitModel()
        surv_fit <- survfit(fit)
        plot(surv_fit, col = 1:3, main = paste("Survival Probability by", input$predictor),
             xlab = "Time", ylab = "Delivery-as-Event Probability", mark.time = TRUE)
        if (input$strataVar != "None") {
            legend("bottomright", legend = levels(ob_data[[input$strataVar]]), col = 1:3, lty = 1)
        }
    })
    
    output$cumHazPlot <- renderPlot({
        fit <- fitModel()
        surv_fit <- survfit(fit)
        plot(surv_fit, fun = "cumhaz", col = 1:3, main = paste("Cumulative Hazard by", input$predictor),
             xlab = "Time", ylab = "Cumulative Hazard of Delivery_as_Event", mark.time = TRUE)
        if (input$strataVar != "None") {
            legend("topleft", legend = levels(ob_data[[input$strataVar]]), col = 1:3, lty = 1)
        }
    })
    
    output$kmPlot <- renderPlot({
        fit <- fitModel()
        ggsurvplot(survfit(fit), data = ob_data, conf.int = FALSE, risk.table = TRUE, fun = "event",
                   title = paste("Kaplan-Meier Plot by", input$predictor))
    })
    
    output$hrPlot <- renderPlot({
        fit <- fitModel()
        ggforest3(fit, data = ob_data) + ggtitle(paste("Hazard Ratios by", input$predictor))
    })
    
    output$multiCoeffs <- renderPlot({
        fit <- fitMultinom()
        if (is.null(fit)) {
            print("Model fitting failed.")  # Debugging statement
            return()
        }
        coef_df <- data.frame(
            Predictor = rownames(coef(fit)),
            Coefficient = coef(fit)[, 1],
            StdError = summary(fit)$standard.errors[, 1]
        )
        ggplot(coef_df, aes(x = Predictor, y = Coefficient, fill = Coefficient)) +
            geom_bar(stat = "identity") +
            theme_minimal() +
            labs(title = paste("Multinomial Logistic Regression Coefficients by", input$multinomPredictor),
                 y = "Coefficient Value", x = "") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))
    })
    
    output$varImportancePlot <- renderPlot({
        rf_model <- randomForest(as.formula(paste(input$varImpOutcome, "~ .")), data = ob_data)
        importance <- importance(rf_model)
        importance_df <- data.frame(
            Predictor = rownames(importance),
            Importance = importance[, 1]
        )
        ggplot(importance_df, aes(x = reorder(Predictor, Importance), y = Importance, fill = Importance)) +
            geom_bar(stat = "identity") +
            coord_flip() +
            labs(title = paste("Variable Importance for", input$varImpOutcome),
                 x = "Predictors", y = "Importance") +
            theme_minimal() +
            theme(axis.text.x = element_text(size = 12), axis.text.y = element_text(size = 12)) +
            scale_fill_gradient(low = "blue", high = "red")
    })
}

shinyApp(ui = ui, server = server)

```